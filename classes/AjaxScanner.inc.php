<?php

require_once("XmlValidator.inc.php");
require_once("FileInfo.inc.php");

class AjaxScanner {

    function __construct() {
        $this->log_filename = 'scan_log.xml';
        $this->AJAX_HEADER_DIRS = 'DIRS';
        $this->AJAX_HEADER_ERROR = 'ERR';
        $this->AJAX_TMP_FILE = 'ajax_scnnr_tbnj.tmp';
        $this->MAX_EXECUTION_DURATION = 20;
        $this->TYPE_ANY = 0;
        $this->TYPE_FOLDER = 1;
        $this->TYPE_FILE = 2;
        $this->ACTION_SKIP = 0;
        $this->ACTION_PROCESS = 1;

        $this->scan_skip_path_wildcard = array(); // wildcards to exclude from scanning
        $this->files_found = 0;
        $this->files_node = null;
        $this->xmlResult = '';

        $this->SCRIPT_START = time();

        $this->dom = new DOMDocument("1.0", "utf-8");
        $this->dom->formatOutput = true;
        $this->files_node = $this->dom->createElement("files");
        $this->dom->appendChild($this->files_node);
        $this->homedir = dirname(dirname(__FILE__));


        global $project_root_dir;

        #For creating temprorary queue for further antimalware/whitelist scan
        $this->GENERATE_FILE_QUEUE = true;
        $this->tmp_queue_filename = $project_root_dir . '/scan_queue.tmp.txt';

    }

    function throwTimeout() {
        echo $this->AJAX_HEADER_ERROR . "\n";
        echo "File listing timeout. Try to increase an interval in settings.\n";
        exit;
    }

    function fileExecutor($file_path, $type, $action_type) {
        if (time() - $this->SCRIPT_START > $this->MAX_EXECUTION_DURATION) {
           $this->throwTimeout();
        }

        if ($action_type == $this->ACTION_PROCESS) {
            $fileinfo = new FileInfo($file_path);
            $fileinfo_node = $fileinfo->getXMLNode();      
                
            if ($this->GENERATE_FILE_QUEUE && is_file($fileinfo->absolute_name)) {              
                $queue_entry = $fileinfo->absolute_name  . ' ' . $fileinfo->md5 . PHP_EOL;
                file_put_contents($this->tmp_queue_filename, $queue_entry, FILE_APPEND);           
            }
                                                                                                                 
            $this->dom->documentElement->appendChild($this->dom->importNode($fileinfo_node, true));
            $this->files_found++;
        } else if ($action_type == $this->ACTION_SKIP) {
            // TODO: Do something with skipped item
            // fputs($file_handle, "* SKIPPED *************************************** " . $file_path);
            
        }
    }

    function getXMLFilelist() {
        return implode('', file($this->AJAX_TMP_FILE));
    }

    function finalizeExecutor() {
        if ($fHandle = fopen($this->AJAX_TMP_FILE, "a")) {
            $nodeList = $this->files_node->childNodes;
            $num = $nodeList->length;
            for ($i = 0;$i < $num;$i++) {
                fputs($fHandle, $this->dom->saveXML($nodeList->item($i)));
            }
            fclose($fHandle);
        } else {
            ob_end_clean();
            // output result for ajax processing
            echo $this->AJAX_HEADER_ERROR . "\n";
            echo "Cannot write to file " . $this->log_filename . "\n";
        }


    }

    function cleanUp() {
        @unlink($this->AJAX_TMP_FILE);
    }

    function setUp() {
    }

    function performScanning() {
        $dir_list = explode("\n", $_POST['s']);
        $time_of_start = time();
        while (true) {
            $dir_list = array_merge($this->folderWalker(array_shift($dir_list), $this->files_found), $dir_list);
            $current_time = time();
            if (($current_time - $time_of_start >= $this->MAX_EXECUTION_DURATION) || (count($dir_list) < 1)) break;
        }
        $this->finalizeExecutor();
        //ob_end_clean();
        // output result for ajax processing

        $report = $this->AJAX_HEADER_DIRS . "\n";         
        $report .= $this->files_found . "\n";
        $report .= implode("\n", $dir_list);
        return $report;
    }   

    function getInterval() {
      return $this->MAX_EXECUTION_DURATION; 
    }

    function setInterval($val) {
      $this->MAX_EXECUTION_DURATION = $val; 
    }

    function folderWalker($path, &$files_found) {
        if ($path === ".") 
            $path = $_SERVER['DOCUMENT_ROOT'];
        $dir_list = array();
        if ($current_dir = opendir($path)) {
            while ($file = readdir($current_dir)) {
                if ($file == '.' || $file == '..' || is_link($file) || $file == basename($this->homedir)) continue;
                $name = $file;
                $file = $path . '/' . $file;
                // skip path entries from the list
                foreach ($this->scan_skip_path_wildcard as $item) {
                    if (preg_match('|' . $item . '|i', $file, $found)) {
                        foreach ($this->scan_iterator_func as $callback) {
                            $callback($file, TYPE_ANY, ACTION_SKIP);
                        }
                        continue;
                    }
                }
                $file_type = $this->TYPE_FILE;
                if (is_dir($file)) {
                    $dir_list[] = $file;
                    $file_type = $this->TYPE_FOLDER;
                }
                $this->fileExecutor($file, $file_type, $this->ACTION_PROCESS);
            }
            closedir($current_dir);
        }
        return $dir_list;
    }
} // End of class
